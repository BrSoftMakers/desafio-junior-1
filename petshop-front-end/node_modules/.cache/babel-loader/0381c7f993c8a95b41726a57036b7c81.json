{"ast":null,"code":"'use strict';\n\nimport CanceledError from './CanceledError.js';\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\n\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n    const token = this; // eslint-disable-next-line func-names\n\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n\n      token._listeners = null;\n    }); // eslint-disable-next-line func-names\n\n    this.promise.then = onfulfilled => {\n      let _resolve; // eslint-disable-next-line func-names\n\n\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n\n\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n  /**\n   * Subscribe to the cancel signal\n   */\n\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n\n    const index = this._listeners.indexOf(listener);\n\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n\n\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n\n}\n\nexport default CancelToken;","map":{"version":3,"names":["CanceledError","CancelToken","constructor","executor","TypeError","resolvePromise","promise","Promise","promiseExecutor","resolve","token","then","cancel","_listeners","i","length","onfulfilled","_resolve","subscribe","reject","unsubscribe","message","config","request","reason","throwIfRequested","listener","push","index","indexOf","splice","source","c"],"sources":["/home/eduardo/Repositorios/desafio-junior-1/petshop-front-end/node_modules/axios/lib/cancel/CancelToken.js"],"sourcesContent":["'use strict';\n\nimport CanceledError from './CanceledError.js';\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}